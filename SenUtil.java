// package kitty2.util;

import	java.io.*;
import	java.util.*;

import	net.java.sen.*;

class SenUtil {

	// state variables
	private static boolean		sahenFlag;
	private static boolean		suushiFlag;
	private static boolean		settoushiFlag;
	// private static boolean		kigouFlag;
	private static boolean		meishiFlag;

	// values for sen
	// unicode-encoded characters generated by native2ascii command
	private final static String	J_NOUN = "\u540d\u8a5e";
	private final static String	J_VERB = "\u52d5\u8a5e";
	private final static String	J_ADJECTIVE = "\u5f62\u5bb9\u8a5e";
	private final static String	J_ADVERB = "\u526f\u8a5e";
	private final static String	J_PROPER_NOUN = "\u540d\u8a5e-\u56fa\u6709\u540d\u8a5e";
	private final static String	J_NUMBER_NOUN = "\u540d\u8a5e-\u6570";
	private final static String	J_KANDOUSHI = "\u611f\u52d5\u8a5e";
	private final static String	J_SAHEN_NOUN = "\u540d\u8a5e-\u30b5\u5905";
	private final static String	J_SAHEN_VERB = "\u3059\u308b";
	private final static String	J_SETSUBI = "\u63a5\u5c3e";
	private final static String	J_SETTOUSHI = "\u63a5\u982d\u8a5e";
	private final static String	J_RENTAISHI = "\u9023\u4f53\u8a5e";
	private final static String	J_UNKNOWN_WORD = "\u672a\u77e5\u8a9e";
	private final static String	J_HIJIRITSU = "\u975e\u81ea\u7acb";
	private final static String	J_KIGOU = "\u8a18\u53f7";
	private final static String	J_KUTEN = "\u53e5\u70b9";
	private final static String	J_TOUTEN = "\u8aad\u70b9";
	private final static String	J_KAKKOHIRAKU = "\u62ec\u5f27\u958b";

	// default values
	private final static String	PART_NO_MATCH = "_default";
	private final static String	PART_PROPER_NOUN = "_proper_noun";
	private final static String	PART_LINE_INTERVAL = "_large_interval";
	private final static String	PART_LETTER_INTERVAL = "_small_interval";
	private final static String	PART_PERIOD_INTERVAL = "_middle_interval";
	private final static String	PART_COMMA_INTERVAL = "_small_interval";
	private final static String	PART_DOTS_INTERVAL = "_large_interval";


	private SenUtil() {}  // prevent to make instances


	/**
	 * check if the given string contains only basic latin characters.
	 *
	 * @author Mitsuru Minakuchi
	 * @version 1.0
	 */
	public static boolean isBasicLatin(String str) {
		for (int i = 0; i < str.length(); i++) {
			if (Character.UnicodeBlock.of(str.charAt(i)) != Character.UnicodeBlock.BASIC_LATIN)  return false;
		}
		return true;
	}


	/**
	 * make "bunsetsu" (segments) from given tokens, which generated by StringTagger#analyze.
	 * this method connects a sequence of nouns and undefined words into one segment.
	 *
	 * @author Mitsuru Minakuchi
	 * @version 1.0
	 */
	public static List<String> getLongerSegmentsByList(Token[] tokens) {
		sahenFlag = false;
		suushiFlag = false;
		settoushiFlag = false;
		// kigouFlag = false;
		meishiFlag = false;

		List<String> segments = new ArrayList<String>();

		StringBuilder workingSeg = new StringBuilder();

		for (Token t : tokens) {
			String p = t.getPos();
// System.err.println(t.toString() + ", " + p);
			if (J_SAHEN_VERB.equals(t.getBasicString()))  p = J_SAHEN_VERB;
			if (p.startsWith(J_UNKNOWN_WORD))  p = J_PROPER_NOUN;

			if (isNewSegment(p)) {
				if (workingSeg.length() != 0 && !settoushiFlag && !(p.startsWith(J_NOUN) && meishiFlag)) {
				// flush the last segment
// System.err.println("segment: " + workingSeg);
					segments.add(workingSeg.toString());
					workingSeg = new StringBuilder();
				}
			}
			workingSeg.append(t.toString());
			meishiFlag = p.startsWith(J_NOUN);
			settoushiFlag = isSettoushiLonger(p);
		}
		if (workingSeg.length() != 0)  segments.add(workingSeg.toString());

		return segments;
	}

	/**
	 * make "bunsetsu" (segments) from given tokens, which generated by StringTagger#analyze.
	 * this method connects a sequence of nouns and undefined words into one segment.
	 *
	 * @author Mitsuru Minakuchi
	 * @version 1.0
	 */
	public static List<String> getLongerSegmentsByList(String string) {
		try {
			StringTagger senTagger = StringTagger.getInstance();
			Token[] tokens = senTagger.analyze(string);
			return SenUtil.getLongerSegmentsByList(tokens);
		} catch (IOException ioe) {
			ioe.printStackTrace();
			return null;
		} catch (NullPointerException npe) {
			return new ArrayList<String>();
		}
	}

	/**
	 * make "bunsetsu" (segments) from given tokens, which generated by StringTagger#analyze.
	 * this method connects a sequence of nouns and undefined words into one segment.
	 *
	 * @author Mitsuru Minakuchi
	 * @version 1.0
	 */
	public static String[] getLongerSegments(Token[] tokens) {
		List<String> segments = getLongerSegmentsByList(tokens);
		return segments.toArray(new String[0]);
	}

	/**
	 * make "bunsetsu" (segments) from given tokens, which generated by StringTagger#analyze.
	 * this method connects a sequence of nouns and undefined words into one segment.
	 *
	 * @author Mitsuru Minakuchi
	 * @version 1.0
	 */
	public static String[] getLongerSegments(String string) {
		try {
			StringTagger senTagger = StringTagger.getInstance();
			Token[] tokens = senTagger.analyze(string);
			return SenUtil.getLongerSegments(tokens);
		} catch (IOException ioe) {
			ioe.printStackTrace();
			return null;
		} catch (NullPointerException npe) {
			return new String[0];
		}
	}

	/**
	 * make "bunsetsu" (segments) from given tokens, which generated by StringTagger#analyze.
	 *
	 * @author Mitsuru Minakuchi
	 * @version 1.0
	 */
	public static List<String> getSegmentsByList(Token[] tokens) {
		sahenFlag = false;
		suushiFlag = false;
		settoushiFlag = false;
		// kigouFlag = false;

		List<String> segments = new ArrayList<String>();

		StringBuilder workingSeg = new StringBuilder();

		for (Token t : tokens) {
			String p = t.getPos();
System.err.println(t.toString() + ", " + p);
			if (J_SAHEN_VERB.equals(t.getBasicString()))  p = J_SAHEN_VERB;
			if (p.startsWith(J_UNKNOWN_WORD))  p = J_PROPER_NOUN;

			if (isNewSegment(p)) {
				if (workingSeg.length() != 0 && !settoushiFlag) {
				// flush the last segment
System.err.println("segment: " + workingSeg);
					segments.add(workingSeg.toString());
					workingSeg = new StringBuilder();
				}
				settoushiFlag = isSettoushi(p);
			}
			workingSeg.append(t.toString());
		}
		if (workingSeg.length() != 0)  segments.add(workingSeg.toString());

		return segments;
	}

	/**
	 * make "bunsetsu" (segments) from given tokens, which generated by StringTagger#analyze.
	 *
	 * @author Mitsuru Minakuchi
	 * @version 1.0
	 */
	public static List<String> getSegmentsByList(String string) {
		if (string == null)  return new ArrayList<String>();
		try {
			StringTagger senTagger = StringTagger.getInstance();
			Token[] tokens = senTagger.analyze(string);
			return SenUtil.getSegmentsByList(tokens);
		} catch (IOException ioe) {
			ioe.printStackTrace();
			return null;
		} catch (NullPointerException npe) {
			return new ArrayList<String>();
		}
	}

	/**
	 * make "bunsetsu" (segments) from given tokens, which generated by StringTagger#analyze.
	 *
	 * @author Mitsuru Minakuchi
	 * @version 1.0
	 */
	public static String[] getSegments(Token[] tokens) {
		List<String> segments = getSegmentsByList(tokens);
		return segments.toArray(new String[0]);
	}

	/**
	 * make "bunsetsu" (segments) from given tokens, which generated by StringTagger#analyze.
	 *
	 * @author Mitsuru Minakuchi
	 * @version 1.0
	 */
	public static String[] getSegments(String string) {
		if (string == null)  return new String[0];
		try {
			StringTagger senTagger = StringTagger.getInstance();
			Token[] tokens = senTagger.analyze(string);
			return SenUtil.getSegments(tokens);
		} catch (IOException ioe) {
			ioe.printStackTrace();
			return null;
		} catch (NullPointerException npe) {
			return new String[0];
		}
	}

	
	private static boolean isSettoushi(String pos) {
		return pos.startsWith(J_SETTOUSHI) || (pos.indexOf(J_KAKKOHIRAKU) != -1);
	}

	private static boolean isSettoushiLonger(String pos) {
		return pos.startsWith(J_SETTOUSHI) || pos.startsWith(J_RENTAISHI) || (pos.indexOf(J_KAKKOHIRAKU) != -1);
	}

	private static boolean isNewSegment(String pos) {
		// a new segment always begins after a sequence of non-letter characters (kigou)
		/* currently not used.
		if (kigouFlag && !pos.startsWith(J_KIGOU)) {
			kigouFlag = false;
			return true;
		}
		*/

		// check a sequence of number letters
		if (pos.startsWith(J_NUMBER_NOUN)) {
			if (suushiFlag) {
				return false;
			} else {
				suushiFlag = true;
				return true;
			}
		}
		suushiFlag = false;

		// non-letter characters are included to the next segment (need to reconsider)
		if (pos.startsWith(J_KIGOU)) {
			if (pos.indexOf(J_KAKKOHIRAKU) != -1)  return true;
			// kigouFlag = true;
			return false;
		}


		if (pos.indexOf(J_SETSUBI) != -1)  return false;
		if (pos.indexOf(J_HIJIRITSU) != -1)  return false;

		return  (pos.startsWith(J_NOUN) ||
			 pos.startsWith(J_VERB) ||
			 pos.startsWith(J_ADJECTIVE) ||
			 pos.startsWith(J_ADVERB) ||
			 pos.startsWith(J_KANDOUSHI) ||
			 pos.startsWith(J_SETTOUSHI) ||
			 pos.startsWith(J_RENTAISHI) ||
			 pos.startsWith(J_UNKNOWN_WORD)
			 );
	}


	public static void main(String[] args) throws Exception {
		StringTagger senTagger = StringTagger.getInstance();
		Token[] tokens = senTagger.analyze(args[0]);
		String[] segments = SenUtil.getSegments(tokens);
		for (String str : segments)  System.out.println(str);
		segments = SenUtil.getLongerSegments(tokens);
		for (String str : segments)  System.out.println(str);
	}

}
